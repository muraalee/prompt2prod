// FIX: Refactored to use Firebase v9 compat API to resolve module export errors.
// This is necessary when the environment/build setup doesn't correctly handle
// the modular SDK's entry points, which appears to be the case based on the errors.
import firebase from "firebase/compat/app";
import "firebase/compat/firestore";

import { firebaseConfig } from '../firebaseConfig';
import type { BlogPost } from '../types';

// Initialize Firebase
if (firebase.apps.length === 0) {
  firebase.initializeApp(firebaseConfig);
}
const db = firebase.firestore();

const postsCollection = db.collection('posts');

// Type for creating a post, without fields generated by the server
export type NewBlogPost = Omit<BlogPost, 'id' | 'createdAt'>;

export const getPosts = async (): Promise<BlogPost[]> => {
  const postsQuery = postsCollection.orderBy('createdAt', 'desc');
  const postsSnapshot = await postsQuery.get();
  const postsList = postsSnapshot.docs.map(docSnapshot => {
    const data = docSnapshot.data();
    return {
      id: docSnapshot.id,
      ...data,
      // Convert Firestore Timestamp to ISO string to match existing type
      createdAt: (data.createdAt as firebase.firestore.Timestamp)?.toDate().toISOString() || new Date().toISOString(),
    } as BlogPost
  });
  return postsList;
};

export const getPost = async (id: string): Promise<BlogPost | null> => {
    const postDocRef = postsCollection.doc(id);
    const postDoc = await postDocRef.get();

    if (postDoc.exists) {
        const data = postDoc.data();
        return {
            id: postDoc.id,
            ...data,
            createdAt: (data.createdAt as firebase.firestore.Timestamp)?.toDate().toISOString() || new Date().toISOString(),
        } as BlogPost;
    } else {
        return null;
    }
};

export const addPost = async (post: NewBlogPost): Promise<string> => {
  const docRef = await postsCollection.add({
    ...post,
    createdAt: firebase.firestore.FieldValue.serverTimestamp()
  });
  return docRef.id;
};
